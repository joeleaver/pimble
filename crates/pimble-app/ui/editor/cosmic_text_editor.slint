// Cosmic Text Editor Component
// A rich text editor built on cosmic-text, rendered to an Image
// Supports virtualized scrolling and zoom

import { Theme } from "../theme.slint";

// Icon button for table toolbar
component TableToolbarButton inherits Rectangle {
    in property <string> icon-text: "";
    in property <string> tooltip-text: "";
    in property <bool> is-destructive: false;

    callback clicked();

    width: 28px;
    height: 28px;
    border-radius: 4px;
    background: touch.has-hover ? (is-destructive ? #5a2020 : Theme.hover) : transparent;

    touch := TouchArea {
        mouse-cursor: pointer;
        clicked => { root.clicked(); }
    }

    Text {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        text: root.icon-text;
        font-family: "Material Design Icons";
        font-size: 18px;
        color: root.is-destructive ? #f48771 : Theme.text;
    }
}

// Floating toolbar for table operations
component TableToolbar inherits Rectangle {
    in property <bool> show-toolbar: false;
    in property <float> toolbar-x: 0;
    in property <float> toolbar-y: 0;

    callback add-row-above();
    callback add-row-below();
    callback add-column-left();
    callback add-column-right();
    callback delete-row();
    callback delete-column();

    x: toolbar-x * 1px;
    y: toolbar-y * 1px;
    width: 200px;
    height: 36px;
    visible: show-toolbar;
    background: Theme.panel-bg;
    border-radius: 6px;
    drop-shadow-blur: 8px;
    drop-shadow-color: #00000080;
    drop-shadow-offset-y: 2px;

    HorizontalLayout {
        padding: 4px;
        spacing: 2px;
        alignment: center;

        // Add row above
        TableToolbarButton {
            icon-text: "\u{F04F4}";  // table-row-plus-before
            tooltip-text: "Add row above";
            clicked => { root.add-row-above(); }
        }

        // Add row below
        TableToolbarButton {
            icon-text: "\u{F04F3}";  // table-row-plus-after
            tooltip-text: "Add row below";
            clicked => { root.add-row-below(); }
        }

        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Theme.border;
        }

        // Add column left
        TableToolbarButton {
            icon-text: "\u{F04ED}";  // table-column-plus-before
            tooltip-text: "Add column left";
            clicked => { root.add-column-left(); }
        }

        // Add column right
        TableToolbarButton {
            icon-text: "\u{F04EC}";  // table-column-plus-after
            tooltip-text: "Add column right";
            clicked => { root.add-column-right(); }
        }

        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Theme.border;
        }

        // Delete row
        TableToolbarButton {
            icon-text: "\u{F04F5}";  // table-row-remove
            tooltip-text: "Delete row";
            is-destructive: true;
            clicked => { root.delete-row(); }
        }

        // Delete column
        TableToolbarButton {
            icon-text: "\u{F04EE}";  // table-column-remove
            tooltip-text: "Delete column";
            is-destructive: true;
            clicked => { root.delete-column(); }
        }
    }
}

// Vertical scrollbar component
component Scrollbar inherits Rectangle {
    in property <float> viewport-size: 100;    // Visible area height
    in property <float> content-size: 200;     // Total content height
    in-out property <float> scroll-position: 0; // Current scroll position

    // Callback when scroll position changes - passes the new value directly
    callback scrolled(float);
    // Callback when position changes during drag (for syncing, not rendering)
    callback position-changed(float);
    // Callback when drag starts/ends
    callback drag-started();
    callback drag-ended();

    // Computed properties
    property <float> scrollable-range: max(0, content-size - viewport-size);
    property <float> thumb-ratio: viewport-size >= content-size ? 1.0 : viewport-size / content-size;
    property <float> thumb-height-px: max(30, (self.height / 1px) * thumb-ratio);
    property <float> track-height: self.height / 1px - thumb-height-px;
    property <float> thumb-position: scrollable-range > 0 ? (scroll-position / scrollable-range) * track-height : 0;

    // Drag state (stored at root level so coordinates are stable)
    property <bool> is-dragging: false;
    property <float> drag-start-y: 0;
    property <float> drag-start-scroll: 0;

    width: 14px;
    background: Theme.panel-bg;

    // Only show scrollbar when content exceeds viewport
    visible: content-size > viewport-size;

    // Track (full height touch area for clicking AND dragging)
    track-touch := TouchArea {
        x: 0px;
        y: 0px;
        width: root.width;
        height: root.height;

        pointer-event(event) => {
            if (event.kind == PointerEventKind.down && event.button == PointerEventButton.left) {
                let click-y = self.mouse-y / 1px;
                let thumb-top = root.thumb-position;
                let thumb-bottom = root.thumb-position + root.thumb-height-px;

                // Check if click is on the thumb
                if (click-y >= thumb-top && click-y <= thumb-bottom) {
                    // Start dragging
                    root.is-dragging = true;
                    root.drag-start-y = click-y;
                    root.drag-start-scroll = root.scroll-position;
                    root.drag-started();
                } else {
                    // Click on track - jump to position
                    let target-ratio = click-y / (root.height / 1px);
                    let new-scroll = max(0, min(root.scrollable-range, target-ratio * root.scrollable-range));
                    root.scrolled(new-scroll);
                }
            }
            if (event.kind == PointerEventKind.up) {
                if (root.is-dragging) {
                    root.is-dragging = false;
                    root.scrolled(root.scroll-position);
                    root.drag-ended();
                }
            }
        }

        moved => {
            if (root.is-dragging) {
                // Use track coordinates (stable, doesn't move)
                let current-y = self.mouse-y / 1px;
                let delta-y = current-y - root.drag-start-y;
                let scroll-delta = (delta-y / root.track-height) * root.scrollable-range;
                let new-scroll = max(0, min(root.scrollable-range, root.drag-start-scroll + scroll-delta));
                root.position-changed(new-scroll);
            }
        }
    }

    // Track visual
    Rectangle {
        x: 2px;
        y: 0px;
        width: parent.width - 4px;
        height: parent.height;
        background: transparent;

        // Thumb (visual only - drag is handled by track touch area)
        thumb := Rectangle {
            x: 0px;
            y: root.thumb-position * 1px;
            width: parent.width;
            height: root.thumb-height-px * 1px;
            background: track-touch.has-hover || root.is-dragging ? Theme.scrollbar-hover : Theme.scrollbar-thumb;
            border-radius: 4px;
        }
    }
}

// Cosmic text editor component
// Renders text using cosmic-text to a pixel buffer displayed as an Image
export component CosmicTextEditor inherits Rectangle {
    in-out property <string> text: "";
    in-out property <image> rendered-image;
    in-out property <bool> has-focus: false;

    // Editor dimensions
    in property <length> editor-width: self.width;
    in property <length> editor-height: self.height;

    // Scroll state
    in-out property <float> scroll-y: 0;           // Current scroll position (pixels)
    in-out property <float> target-scroll-y: 0;    // Target for smooth scrolling
    in-out property <float> max-scroll-y: 0;       // Maximum scroll (set by Rust based on content height)
    in-out property <float> content-height: 0;     // Total content height (set by Rust)

    // Zoom state
    in-out property <float> zoom: 1.0;             // Zoom level (1.0 = 100%)
    in property <float> min-zoom: 0.25;            // Allow more zoom out
    in property <float> max-zoom: 4.0;             // Allow more zoom in

    // Zoom step size (finer control)
    property <float> zoom-step: 0.05;              // 5% increments for smooth zooming

    // Size tracking for resize/scroll detection
    in-out property <float> last-width: 0;
    in-out property <float> last-height: 0;
    in-out property <float> last-scroll-y: -1;
    in-out property <float> last-zoom: -1;

    // Table cell selection state (set from Rust)
    in-out property <bool> table-cell-selected: false;
    in-out property <float> table-toolbar-x: 0;      // X position for toolbar
    in-out property <float> table-toolbar-y: 0;      // Y position for toolbar (above selected cell)

    // Callbacks to Rust
    callback text-changed(string);
    callback key-pressed(string, bool, bool, bool);  // key, shift, ctrl, alt
    callback mouse-clicked(float, float);            // x, y in pixels (viewport-relative)
    callback mouse-dragged(float, float);            // x, y in pixels (viewport-relative)
    callback request-render(float, float, float, float);  // width, height, scroll-y, zoom
    callback focus-changed(bool);                    // Focus state changed
    callback request-blink-update();                 // Request cursor blink update

    // Table toolbar callbacks
    callback table-add-row-above();
    callback table-add-row-below();
    callback table-add-column-left();
    callback table-add-column-right();
    callback table-delete-row();
    callback table-delete-column();

    min-width: 100px;
    min-height: 50px;
    background: transparent;
    clip: true;

    // Flag to track if scrollbar is being dragged (prevents timer interference)
    property <bool> scrollbar-dragging: false;
    // Track last rendered scroll position for drag timer
    property <float> drag-last-rendered-scroll: -1;

    // Cursor blink timer (100ms intervals, only when focused)
    blink-timer := Timer {
        interval: 100ms;
        running: root.has-focus;
        triggered => {
            root.request-blink-update();
        }
    }

    // Timer for scrollbar drag rendering (30fps = 33ms)
    drag-render-timer := Timer {
        interval: 33ms;
        running: root.scrollbar-dragging;
        triggered => {
            // Only render if scroll position changed
            if (root.scroll-y != root.drag-last-rendered-scroll) {
                root.drag-last-rendered-scroll = root.scroll-y;
                root.target-scroll-y = root.scroll-y;
                root.last-scroll-y = root.scroll-y;
                root.request-render(editor-area.width / 1px, root.height / 1px, root.scroll-y, root.zoom);
            }
        }
    }

    // Smooth scroll animation (for mouse wheel scrolling)
    scroll-animation := Timer {
        interval: 16ms;  // ~60fps
        running: root.scroll-y != root.target-scroll-y && !root.scrollbar-dragging;
        triggered => {
            // Lerp towards target
            let diff = root.target-scroll-y - root.scroll-y;
            if (diff.abs() < 0.5) {
                root.scroll-y = root.target-scroll-y;
            } else {
                root.scroll-y = root.scroll-y + diff * 0.25;
            }
            // Request render for the new scroll position
            root.last-scroll-y = root.scroll-y;
            root.request-render(editor-area.width / 1px, root.height / 1px, root.scroll-y, root.zoom);
        }
    }

    // Timer to check for size/zoom changes (not scroll - that's handled by scrollbar/animation)
    render-timer := Timer {
        interval: 100ms;  // Slower interval
        running: true;
        triggered => {
            // Only check size and zoom, not scroll (to avoid fighting with scrollbar)
            if (root.width > 10px && root.height > 10px && !root.scrollbar-dragging) {
                if (root.width / 1px != root.last-width ||
                    root.height / 1px != root.last-height ||
                    (root.zoom - root.last-zoom).abs() > 0.001) {
                    root.last-width = root.width / 1px;
                    root.last-height = root.height / 1px;
                    root.last-scroll-y = root.scroll-y;
                    root.last-zoom = root.zoom;
                    root.request-render(editor-area.width / 1px, root.height / 1px, root.scroll-y, root.zoom);
                }
            }
        }
    }

    HorizontalLayout {
        spacing: 0px;

        // Editor area (text image + input handling)
        editor-area := Rectangle {
            horizontal-stretch: 1;
            background: transparent;
            clip: true;

            // The rendered text image
            Image {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                source: root.rendered-image;
                image-fit: fill;
                image-rendering: pixelated;
            }

            // Focus scope for keyboard input
            focus-scope := FocusScope {
                x: 0px;
                y: 0px;
                width: 100%;
                height: 100%;

                focus-changed-event => {
                    root.has-focus = self.has-focus;
                    root.focus-changed(self.has-focus);
                    if (self.has-focus) {
                        root.request-render(editor-area.width / 1px, root.height / 1px, root.scroll-y, root.zoom);
                    }
                }

                key-pressed(event) => {
                    // Handle zoom with Ctrl+Plus/Minus (finer steps)
                    if (event.modifiers.control) {
                        if (event.text == "+" || event.text == "=") {
                            root.zoom = min(root.max-zoom, root.zoom + root.zoom-step);
                            accept
                        } else if (event.text == "-") {
                            root.zoom = max(root.min-zoom, root.zoom - root.zoom-step);
                            accept
                        } else if (event.text == "0") {
                            root.zoom = 1.0;  // Reset zoom
                            accept
                        }
                    }
                    // Pass other keys to Rust for handling
                    root.key-pressed(
                        event.text,
                        event.modifiers.shift,
                        event.modifiers.control,
                        event.modifiers.alt
                    );
                    accept
                }
            }

            // Touch area for mouse input and scrolling
            touch := TouchArea {
                x: 0px;
                y: 0px;
                width: 100%;
                height: 100%;

                clicked => {
                    focus-scope.focus();
                    root.mouse-clicked(self.mouse-x / 1px, self.mouse-y / 1px);
                }

                pointer-event(event) => {
                    if (event.kind == PointerEventKind.down && event.button == PointerEventButton.left) {
                        focus-scope.focus();
                        root.mouse-clicked(self.mouse-x / 1px, self.mouse-y / 1px);
                    }
                }

                moved => {
                    if (self.pressed) {
                        root.mouse-dragged(self.mouse-x / 1px, self.mouse-y / 1px);
                    }
                }

                scroll-event(event) => {
                    if (event.modifiers.control) {
                        // Ctrl+scroll for zoom (much finer steps - divide by 1000 for smooth zooming)
                        let zoom-delta = -event.delta-y / 1px * root.zoom-step / 100;
                        root.zoom = max(root.min-zoom, min(root.max-zoom, root.zoom + zoom-delta));
                    } else {
                        // Regular scroll
                        let scroll-amount = -event.delta-y / 1px * 50;  // 50px per scroll unit
                        let new-scroll = root.target-scroll-y + scroll-amount;
                        // Clamp to valid range
                        root.target-scroll-y = max(0, min(root.max-scroll-y, new-scroll));
                    }
                    accept
                }
            }

            // Floating table toolbar (appears when table cell is selected)
            TableToolbar {
                show-toolbar: root.table-cell-selected;
                toolbar-x: root.table-toolbar-x;
                toolbar-y: root.table-toolbar-y;

                add-row-above => { root.table-add-row-above(); }
                add-row-below => { root.table-add-row-below(); }
                add-column-left => { root.table-add-column-left(); }
                add-column-right => { root.table-add-column-right(); }
                delete-row => { root.table-delete-row(); }
                delete-column => { root.table-delete-column(); }
            }
        }

        // Scrollbar
        scrollbar := Scrollbar {
            viewport-size: root.height / 1px;
            content-size: root.content-height;
            scroll-position: root.scroll-y;  // One-way binding (read from root)

            drag-started => {
                root.scrollbar-dragging = true;
            }

            drag-ended => {
                root.scrollbar-dragging = false;
            }

            // Sync scroll position during drag (no render - timer handles it)
            position-changed(new-scroll) => {
                root.scroll-y = new-scroll;
            }

            // When scrollbar drag ends, do final update
            scrolled(new-scroll) => {
                root.scroll-y = new-scroll;
                root.target-scroll-y = new-scroll;
                root.last-scroll-y = new-scroll;
                root.request-render(editor-area.width / 1px, root.height / 1px, new-scroll, root.zoom);
            }
        }
    }
}

// Test/demo wrapper for the cosmic text editor
export component CosmicEditorDemo inherits Rectangle {
    in-out property <string> text: "Hello, World!\n\nThis is a test of the cosmic-text based editor.\n\nClick to position cursor, drag to select.";
    in-out property <image> editor-image;

    callback on-text-changed(string);
    callback on-key-pressed(string, bool, bool, bool);
    callback on-mouse-clicked(float, float);
    callback on-mouse-dragged(float, float);
    callback on-request-render(float, float);  // width, height
    callback on-focus-changed(bool);

    background: Theme.editor-bg;

    VerticalLayout {
        padding: 8px;
        spacing: 8px;

        // Header
        Rectangle {
            height: 24px;
            background: #252526;

            HorizontalLayout {
                padding-left: 12px;
                Text {
                    text: "COSMIC TEXT EDITOR (Proof of Concept)";
                    color: Theme.text-muted;
                    font-size: 11px;
                    font-weight: 600;
                    vertical-alignment: center;
                }
            }
        }

        // Editor area
        CosmicTextEditor {
            vertical-stretch: 1;
            text <=> root.text;
            rendered-image <=> root.editor-image;

            text-changed(new-text) => {
                root.on-text-changed(new-text);
            }

            key-pressed(key, shift, ctrl, alt) => {
                root.on-key-pressed(key, shift, ctrl, alt);
            }

            mouse-clicked(x, y) => {
                root.on-mouse-clicked(x, y);
            }

            mouse-dragged(x, y) => {
                root.on-mouse-dragged(x, y);
            }

            request-render(w, h) => {
                root.on-request-render(w, h);
            }

            focus-changed(focused) => {
                root.on-focus-changed(focused);
            }
        }
    }
}
